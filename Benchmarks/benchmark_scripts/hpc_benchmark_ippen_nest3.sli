/*
 *  hpc_benchmark.sli
 *
 *  This file is part of NEST.
 *
 *  Copyright (C) 2004 The NEST Initiative
 *
 *  NEST is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 2 of the License, or
 *  (at your option) any later version.
 *
 *  NEST is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with NEST.  If not, see <http://www.gnu.org/licenses/>.
 *
 */

/*
   This script produces a balanced random network of scale*11250 neurons in
   which the excitatory-excitatory neurons exhibit STDP with
   multiplicative depression and power-law potentiation. A mutual
   equilibrium is obtained between the activity dynamics (low rate in
   asynchronous irregular regime) and the synaptic weight distribution
   (unimodal).

   _new.sli: - iaf_neuron replaced by iaf_psc_alpha
             - simulates Init Time of 0.1 ms before 99.9 ms presim

   This is the standard network investigated in:
   Morrison et al (2007). Spike-timing-dependent plasticity in balanced random networks Neural Comput 19(6):1437-67
   Helias et al (2012). Supercomputers ready for use as discovery machines for neuroscience Front. Neuroinform. 6:26,
   Kunkel et al (2014). Spiking network simulation code for petascale computers. Front. Neuroinform. 8:78
*/
  
%%% PARAMETER SECTION %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% define all relevant parameters: changes should be made here
% all data is placed in the userdict dictionary

% call like:
% nest --userargs=$scale,$nvp,$logfile_base hpc_benchmark.sli

/user_scale statusdict/userargs :: 0 get (_) breakup 0 get double def
/user_nvp statusdict/userargs :: 0 get (_) breakup 1 get int def
(user_scale: ) =only user_scale ==
(user_nvp: ) =only user_nvp ==

(GIT: ) =only statusdict/version :: ==

/nvp user_nvp def % total number of virtual processes
/scale user_scale def %  scaling factor of the network size, total network size = scale*11250 neurons
/Tsim 1000. def % total simulation time in ms
/record_spikes false def % switch to record spikes of excitatory neurons to file
/path_name (./data/sim_out) def % path where all files will have to be written

% -------------------------------------------------------------------------------------
M_INFO setverbosity

/brunel_params
<<

  /virtual_processes nvp  % number of virtual processes to use
  /simtime Tsim ms        % simulated time
  /inisimtime 0.1 ms      % sim time for initial step
  /presimtime 99.9 ms     % simulation time until reaching equilibrium
  /dt         0.1 ms      % simulation step

  /scale scale def
  
  /NE 9000 scale mul round cvi   % number of excitatory neurons
  /NI 2250 scale mul round cvi   % number of inhibitory neurons

  % number of neurons to record spikes from
  /Nrec 1000 

  /tau_syn  0.32582722403722841 ms  % time const. postsynaptic excitatory currents [ms]

  /model_params
   <<
    % Set variables for iaf_psc_exp
    /E_L     0.0  mV  % Resting membrane potential [mV]
    /C_m   250.0  pF  % Capacity of the membrane [pF]
    /tau_m  10.0  ms  % Membrane time constant [ms]
    /t_ref 0.5  ms    % duration of refractory period [ms]
    /V_th   20.0  mV  % Threshold [mV]
    /V_reset 0.0  mV  % Reset Potential [mV]
    /tau_syn_ex 0.32582722403722841 ms  % time const. postsynaptic excitatory currents [ms]
    /tau_syn_in 0.32582722403722841 ms  % time const. postsynaptic excitatory currents [ms]
    /tau_minus 30.0 ms % time constant for STDP (depression)
    % V can be randomly initialized see below
    /V_m 5.7 mV % mean value of membrane potential
   >> 

  /mean_potential 5.7 mV
  /sigma_potential 7.2 mV
 

  /delay  1.5 ms         % synaptic delay, all connections [ms] 

  % synaptic strengths
  /JE 325.78288268410768 0.14 mul pA    % peak of EPSC

  /sigma_w 3.47 pA       % standard dev. of E->E synapses [pA]
  /g  -5.0     
    
  /stdp_params
  <<
    /delay 1.5 ms
    /alpha  0.0513
    /lambda 0.1          % STDP step size
    /mu     0.4          % STDP weight dependence exponent (potentiation)
    /tau_plus 15.0       % time constant for potentiation
  >>
  
  /eta 1.685         % scaling of external stimulus
  /filestem path_name

>> def

% Here we resolve parameter dependencies, by making the independent
% values visible
brunel_params dup using

% create one single random number generator    
rngdict /knuthlfg get 238 CreateRNG /myrng Set

% normal distribution to draw initial membrane potentials from
myrng rdevdict /normal get CreateRDV /normal_dv Set


%%% FUNCTION SECTION %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% obtain memory used by job in way that works on Bluegene and normal Linux
/memory_thisjob_wrapper
{
  memory_thisjob          % returns dict on Bluegene, number otherwise
  DictQ {
    /mem Set
    mem /heap get
    mem /stack get
    add
  } if
} def

/BuildNetwork
{
  
  tic % start timer on construction    
  % set global kernel parameters
  <<
     /total_num_virtual_procs virtual_processes
     /resolution  dt
     /overwrite_files true
     /print_time false
  >> SetKernelStatus

  /iaf_psc_alpha    model_params    SetDefaults

  /iaf_psc_alpha 1 Create  % We do this to get same spike counter as NEST 2.16!

  M_INFO (BuildNetwork)
  (Creating excitatory population.) message  % show message
  /E_neurons /iaf_psc_alpha NE Create def

  /iaf_psc_alpha 1 Create  % We do this to get same spike counter as NEST 2.16!

  M_INFO (BuildNetwork)
  (Creating inhibitory population.) message  % show message
  /I_neurons /iaf_psc_alpha NI Create def

  /N E_neurons size I_neurons size add def

  scale 10 geq
  {
    /CE NE scale cvd div iround def % number of incoming excitatory connections
    /CI NI scale cvd div iround def % number of incomining inhibitory connections    
  }
  { % small networks: 10% connectivity
    /CE NE 0.1 mul iround def % number of incoming excitatory connections
    /CI NI 0.1 mul iround def % number of incomining inhibitory connections    
  } ifelse


  M_INFO (BuildNetwork)
  (Creating excitatory stimulus generator.) message

  model_params using
  /nu_thresh V_th CE tau_m C_m div mul JE mul 1.0 exp mul tau_syn mul div def
  /nu_ext nu_thresh eta mul def
  endusing
    
  /E_stimulus /poisson_generator Create def 
  E_stimulus 
  <<
     /rate nu_ext CE mul 1000. mul
  >> SetStatus     
  
  /I_stimulus /poisson_generator Create def  
  I_stimulus
  <<
     /rate nu_ext CE mul 1000. mul
  >> SetStatus
 
  M_INFO (BuildNetwork)
  (Creating excitatory spike recorder.) message

  record_spikes true eq {
    /recorder_label  filestem (/alpha_) join stdp_params /alpha get cvs join (_spikes) join def
    /E_recorder /spike_recorder Create def
    E_recorder
    << 
      /label recorder_label
    >> SetStatus
  } if

  memory_thisjob_wrapper cvs ( # virt_mem_after_nodes) join logger /log call

  toc /BuildNodeTime Set
  mpi_rank cvs (] ) join (BuildNode time     : ) join  =only BuildNodeTime =only ( s) =

  BuildNodeTime cvs ( # build_time_nodes) join logger /log call
  
  tic

  % Create custom synapse types with appropriate values for
  % our excitatory and inhibitory connections
  /static_synapse_hpc << /delay delay >> SetDefaults
  /static_synapse_hpc /syn_std  CopyModel
  /static_synapse_hpc /syn_ex << /weight JE >> CopyModel
  /static_synapse_hpc /syn_in << /weight JE g mul >> CopyModel
          
  stdp_params /weight JE put    
  /stdp_pl_synapse_hom_hpc stdp_params SetDefaults

  
  M_INFO (BuildNetwork)
  (Connecting stimulus generators.) message
  
  % Connect Poisson generator to neuron      

  E_stimulus E_neurons << /rule (all_to_all) >> << /synapse_model /syn_ex >> Connect
  E_stimulus I_neurons << /rule (all_to_all) >> << /synapse_model /syn_ex >> Connect

  M_INFO (BuildNetwork)
  (Connecting excitatory -> excitatory population.) message

  E_neurons E_neurons << /rule (fixed_indegree) /indegree CE /allow_autapses false /allow_multapses true >> << /synapse_model /stdp_pl_synapse_hom_hpc >> Connect

  M_INFO (BuildNetwork)
  (Connecting inhibitory -> excitatory population.) message

  I_neurons E_neurons << /rule (fixed_indegree) /indegree CI /allow_autapses false /allow_multapses true >> << /synapse_model /syn_in >> Connect

  
  M_INFO (BuildNetwork)
  (Connecting excitatory -> inhibitory population.) message
  
  E_neurons I_neurons << /rule (fixed_indegree) /indegree CE /allow_autapses false /allow_multapses true >> << /synapse_model /syn_ex >> Connect

  
  M_INFO (BuildNetwork)
  (Connecting inhibitory -> inhibitory population.) message

  I_neurons I_neurons << /rule (fixed_indegree) /indegree CI /allow_autapses false /allow_multapses true >> << /synapse_model /syn_in >> Connect


  record_spikes true eq 
  {
    M_INFO (BuildNetwork)
    (Connecting spike recorders.) message
    E_neurons Nrec Take  E_recorder << /rule (all_to_all) >> << /synapse_model /syn_std >> Connect
  } if    

  % read out time used for building    
  toc /BuildEdgeTime Set
  mpi_rank cvs (] ) join (BuildEdge time     : ) join  =only BuildEdgeTime =only ( s) =
  
  BuildEdgeTime cvs ( # build_edge_time ) join logger /log call
  memory_thisjob_wrapper cvs ( # virt_mem_after_edges) join logger /log call

 } def % end of buildnetwork

/RunSimulation
{

   % open log file
   logger /init call
   
   ResetKernel
   statusdict /MPI_Rank known
    {
      /mpi_rank statusdict /MPI_Rank get def
    }
    {
      /mpi_rank 0 def   % serial version
    }
   ifelse

  memory_thisjob_wrapper cvs ( # virt_mem_0) join logger /log call
  
  BuildNetwork

  % ----------------------------------------

  tic

  inisimtime Simulate

  toc /InitTime Set
  mpi_rank cvs (] ) join (Init time   : ) join  =only InitTime   =only ( s\n) =

  memory_thisjob_wrapper cvs ( # virt_mem_after_init) join logger /log call
  InitTime cvs ( # init_time) join logger /log call

  % ----------------------------------------
   
  tic

  presimtime Simulate

  toc /PreparationTime Set
  mpi_rank cvs (] ) join (Preparation time   : ) join  =only PreparationTime   =only ( s\n) =

  memory_thisjob_wrapper cvs ( # virt_mem_after_presim) join logger /log call
  PreparationTime cvs ( # presim_time) join logger /log call

  % ----------------------------------------

  tic

  simtime Simulate    

  toc /SimCPUTime Set

  memory_thisjob_wrapper cvs ( # virt_mem_after_sim) join logger /log call
  SimCPUTime cvs ( # sim_time) join logger /log call

  
%(\nBRN STDP Equilibrium Simulation) =
  mpi_rank cvs (] ) join (Simulation time   : ) join  =only SimCPUTime   =only ( s\n) =

  E_neurons size I_neurons size add cvs ( # num_neurons) join logger /log call
  GetKernelStatus /num_connections get cvs ( # num_connections) join logger /log call
  GetKernelStatus /min_delay get cvs ( # min_delay) join logger /log call
  GetKernelStatus /max_delay get cvs ( # max_delay) join logger /log call
  GetKernelStatus /local_spike_counter get cvs ( # local_spike_counter) join logger /log call

  logger /done call  
} def



/*
    This script defines a logger class used to properly log memory and timing
    information from network simulations. It is used by hpc_benchmark.sli to
    store the information to the log files.
*/

/logger
<<
    /line_counter 0

    % constructor
    /init
    {
      % nothing to do since we only log to stdout
    }

    % logging function
    % expects one operand on stack to write to file
    /log
    {
      /value Set
      
      cout Rank <- ( ) <- value <- endl flush pop
    }

    % closes file
    /done
    {
      % nothing to do since we only log to stdout
    }

>> def


% ------------------------------------------------------------------------------------

RunSimulation  

GetKernelStatus /num_connections get /n_syn Set

% write a little report (process 0)
Rank 0 eq {
  (\nBrunel Network Simulation) =
  (Number of VPs          : ) =only virtual_processes =
  (Number of Neurons      : ) =only N =
  (Number of Synapses     : ) =only n_syn =
  (Node creation time     : ) =only BuildNodeTime =only ( s) =
  (Edge creation time     : ) =only BuildEdgeTime =only ( s) =
  (Init time              : ) =only InitTime =only ( s) =
  (Simulation time        : ) =only SimCPUTime   =only ( s\n) =
  (VmSize of this job     : ) =only memory_thisjob_wrapper =only ( \(k\)B\n) =
  MemoryInfo
} if
